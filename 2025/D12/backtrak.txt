package main

import (
	_ "embed"
	"fmt"
	"strconv"
	"strings"
)

//go:embed input.txt
var inputDay string

type point struct {
	x, y int
}

type form struct {
	l1 int
	l2 int
	l3 int
}

func ligne_to_int(str string) int {
	var size = len(str)
	var res = 0
	for i := 0; i < size; i++ {
		if str[i] == '#' {
			res = res*2 + 1
		} else {
			res = res * 2
		}
	}
	return res
}

func create_form(str string) form {
	var res form
	var lign = strings.Split(str, "\n")
	res.l1 = ligne_to_int(lign[1])
	res.l2 = ligne_to_int(lign[2])
	res.l3 = ligne_to_int(lign[3])
	return res
}

func turn_form_left(str string) string {
	var lign = strings.Split(str, "\n")

	var l1 = string(lign[1][2]) + string(lign[2][2]) + string(lign[3][2]) + "\n"
	var l2 = string(lign[1][1]) + string(lign[2][1]) + string(lign[3][1]) + "\n"
	var l3 = string(lign[1][0]) + string(lign[2][0]) + string(lign[3][0])
	return "n: \n" + l1 + l2 + l3
}

func can_put_form(place []int, len_place int, forme form, start point) bool {
	if start.x+3 > len_place {
		return false
	} else if start.y+3 > len(place) {
		return false
	}
	var modif []int
	modif = append(modif, forme.l1<<(start.x))
	modif = append(modif, forme.l2<<(start.x))
	modif = append(modif, forme.l3<<(start.x))
	for i := range 3 {
		if place[i+start.y]&modif[i] != 0 {
			return false
		}
	}
	return true
}

func put_a_form(place []int, len_place int, forme form, start point) []int {
	var result = place
	var modif []int
	modif = append(modif, forme.l1<<(start.x))
	modif = append(modif, forme.l2<<(start.x))
	modif = append(modif, forme.l3<<(start.x))
	for i := range 3 {
		result[i+start.y] = result[i+start.y] | modif[i]
	}

	return result
}

func no_remain(remain []int) bool {
	for i := range remain {
		if remain[i] != 0 {
			return false
		}
	}
	return true
}

func find_first_empty(place []int, len_place int) (point, bool) {
	height := len(place)
	for y := 0; y < height-3; y++ {
		if place[y] != (1<<len_place)-1 {
			for x := 0; x < len_place-3; x++ {
				if (place[y] & (1 << x)) == 0 {
					return point{x, y}, true
				}
			}
		}
	}
	return point{}, false
}

func backtrack(place []int, len_place int, l_form, l_form_g, l_form_back, l_form_d []form, remain []int) bool {
	if no_remain(remain) {
		return true
	}
	for i := range remain {
		if remain[i] > 0 {
			start, found := find_first_empty(place, len_place)
			if !found {
				return false
			}
			if can_put_form(place, len_place, l_form[i], start) {
				var newPlace = make([]int, len(place))
				copy(newPlace, place)
				newPlace = put_a_form(newPlace, len_place, l_form[i], start)
				var newRemain = make([]int, len(remain))
				copy(newRemain, remain)
				newRemain[i]--
				if backtrack(newPlace, len_place, l_form, l_form_g, l_form_back, l_form_d, newRemain) {
					return true
				}
			} else if can_put_form(place, len_place, l_form_g[i], start) {
				var newPlace = make([]int, len(place))
				copy(newPlace, place)
				newPlace = put_a_form(newPlace, len_place, l_form_g[i], start)
				var newRemain = make([]int, len(remain))
				copy(newRemain, remain)
				newRemain[i]--
				if backtrack(newPlace, len_place, l_form, l_form_g, l_form_back, l_form_d, newRemain) {
					return true
				}

			} else if can_put_form(place, len_place, l_form_back[i], start) {
				var newPlace = make([]int, len(place))
				copy(newPlace, place)
				newPlace = put_a_form(newPlace, len_place, l_form_back[i], start)
				var newRemain = make([]int, len(remain))
				copy(newRemain, remain)
				newRemain[i]--
				if backtrack(newPlace, len_place, l_form, l_form_g, l_form_back, l_form_d, newRemain) {
					return true
				}

			} else if can_put_form(place, len_place, l_form_d[i], start) {
				var newPlace = make([]int, len(place))
				copy(newPlace, place)
				newPlace = put_a_form(newPlace, len_place, l_form_d[i], start)
				var newRemain = make([]int, len(remain))
				copy(newRemain, remain)
				newRemain[i]--
				if backtrack(newPlace, len_place, l_form, l_form_g, l_form_back, l_form_d, newRemain) {
					return true
				}
			}
		}
	}

	return false

}

func part1(input string) int {
	input = strings.TrimSuffix(input, "\n")
	var lines = strings.Split(input, "\n\n")
	var l_form []form
	var l_form_g []form
	var l_form_back []form
	var l_form_d []form
	var reponse = 0
	var compteur = 0

	for _, line := range lines {
		if line[1] == ':' {
			var lg = turn_form_left(line)
			var lback = turn_form_left(lg)
			var ld = turn_form_left(lback)

			l_form = append(l_form, create_form(line))
			l_form_g = append(l_form_g, create_form(lg))
			l_form_back = append(l_form_back, create_form(lback))
			l_form_d = append(l_form_d, create_form(ld))

		} else {
			var lines_pb = strings.Split(line, "\n")
			for _, line_p := range lines_pb {
				var x, y int
				var ligne_p_split = strings.Split(line_p, ":")
				fmt.Sscanf(ligne_p_split[0], "%dx%d", &x, &y)
				var place []int
				for range y {
					place = append(place, 0)
				}

				var remain []int
				var remaining_str = strings.Split(strings.TrimPrefix(ligne_p_split[1], " "), " ")
				var place_p = 0
				var place_p2 = 0
				for _, r_str := range remaining_str {
					var r_, _ = strconv.Atoi(r_str)
					remain = append(remain, r_)
					place_p += r_ * 9
					place_p2 += r_ * 6
				}
				var b_taille = place_p > x*y
				var b_taille2 = place_p2 < x*y
				if b_taille && b_taille2 {
					if backtrack(place, x, l_form, l_form_g, l_form_back, l_form_d, remain) {
						reponse++
					}
				} else if b_taille {
					reponse++
				}
				compteur++
				fmt.Println(compteur)
			}
		}
	}
	return reponse
}

func part2(input string) int {
	input = strings.TrimSuffix(input, "\n")
	var reponse = 0
	return reponse
}

func main() {
	fmt.Println(part2(inputDay))
	fmt.Println(part1(inputDay))
}
